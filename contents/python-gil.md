---
isTIL: false
date: "2023-03-26"
title: "파이썬을 활용한 멀티쓰레드 파헤치기.  (Feat. GIL)"
categories: ["Tip", "Development"]
summary: "파이썬의 멀티쓰레드와 GIL 개념을 알아봅니다."
thumbnail: "./python-gil/th.jpg"
---
### 들어가며,
이번 시간에는 파이썬을 활용한 멀티 쓰레드를 파헤쳐봅니다.  

포스트에 앞서 간단한 퀴즈를 하나 내겠습니다.
아래는 백 만개의 문장으로 구성된 텍스트 데이터셋을 토크나이징을 수행하는 예시입니다.
이때 **싱글 쓰레드, 멀티 쓰레드, 멀티 프로세스**로 실험을 진행해서 처리 시간을 기록해보았습니다.  

실험 환경은 i5-1135g7, (4코어 8쓰레드), RAM 16GB, Python 3.9.12, Window 11입니다.실험 결과, 빠른 시간 순서대로 **23s, 35s, 52s**가 나왔습니다. (앞쪽으로 갈 수록 빠른 것은 무엇일까요?)

각 기법을 빠른 순서대로 올바르게 나열한 것은 무엇일까요?

(실험 코드 전문은 포스트 아래에 첨부하겠습니다.)

```python
#백만 개의 예시 sentence 준비
corpus = ["나는 파이썬 프로그래밍이 정말 재미 없어요"] * 1000000

#각 문장에 대해 토크나이징 수행
def tokenizing_sentences(start_idx, end_idx):
    for idx in range(start_idx, end_idx):
        tokenizer.tokenize(corpus[idx])
```  
### 파이썬 멀티쓰레딩에 숨겨진 비밀
저의 추측은 멀티 쓰레드 > 멀티 프로세스 > 싱글 스레드 순서였습니다.

그리고 그렇게 생각한 근거는 다음과 같습니다.

- 멀티 쓰레딩은 멀티 프로세싱과 다르게 Code, Data, Heap 영역을 공유하므로 별도의 **IPC(Inter Processing Communication)**을 거치지 않는다.
- 즉,  멀티 쓰레딩이 멀티 프로세싱보다 **Context Switching**에 소모되는 비용이적어 **더 빠른 속도로 처리**가 가능할 것이다.  

하지만 놀랍게도 정답은 멀티 프로세스(**23s**) > 싱글 쓰레드(**35s**) > 멀티 쓰레드(**52s**) 입니다! (실행 환경에 따라 2번째와 3번째 순서는 바뀔 수 있어요!)

여기서 더욱 놀라운 점이 있었는데요,

바로 **멀티 쓰레드가 싱글 쓰레드보다도 성능이 안나온다는 점입니다.**

왜 이런 일이 발생했을까요?

비밀은 바로 파이썬의 **GIL(Global Interpreter Lock)** 정책에 있습니다.

파이썬은 GIL 정책을 통해 아래와 같이 쓰레드를 관리합니다.

- 하나의 프로세스 안에 **모든 자원의 락(Lock)을 글로벌**하게 관리한다.
- 따라서 GIL을 통해 아무리 한 프로세스 안에 수 많은 쓰레드가 있다 한들 **한 번에 동시에 여러 개의 쓰레드를 구동할 수 없다.**
- 따라서 멀티 쓰레드는 각 쓰레드를 병렬적으로 처리하지 못하고, 오히려 이 과정에서 Context Switching 때문에 **싱글 쓰레드보다 못한 성능이 나왔다.**

위와 같은 이유 때문에 **파이썬 상에서는 멀티 쓰레드가 온전한 성능을 발휘할 수 없습니다.**

### 그렇다면 파이썬은 왜 GIL 정책을 사용할까요?
TBA

### 파이썬의 Reference Counting and Garbage Collecting
TBA

### Reference
TBA  
